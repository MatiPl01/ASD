Oba rozwiązania nie są optymalne. Pierwsze zadanie lepiej by było rozwiązać, przy pomocy zwykłego algorytmu Quick Sort, którego złożoność pamięciowa wynosi O(log(n)), natomiast w 2. zadaniu algorytm jest błędny i najlepiej by było zastosować algorytm Dijkstry dla reprezentacji LISTOWEJ (nie macierzowej) grafu, bo tak na prawdę mamy graf rzadki, z rozmnażaniem wierzchołków. Każde pole labiryntu powinno być reprezentowane przez 12 wierzchołków, ponieważ mamy 12 różnych stanów (3 prędkości i 4 kierunki -> 3 * 4 = 12 stanów).
